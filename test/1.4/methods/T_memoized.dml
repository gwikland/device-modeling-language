/*
  Â© 2022 Intel Corporation
  SPDX-License-Identifier: MPL-2.0
*/
dml 1.4;
device test;
import "testing.dml";

header %{
    static bool fired = false;
%}
extern bool fired;

memoized method memo_0() {
    fired = true;
}

memoized method memo_0_t() throws {
    fired = true;
    throw;
}

memoized method memo_0_nt() throws {
    fired = true;
}

memoized method memo_1() -> (int) {
    fired = true;
    return 4;
}

memoized method memo_2() -> (int, double) {
    fired = true;
    return (4, 7.2);
}

memoized method memo_2_t() -> (int, double) throws {
    fired = true;
    throw;
}

memoized method memo_2_nt() -> (int, double) throws {
    fired = true;
    return (4, 7.2);
}

memoized independent method indep_memo_0() {
    fired = true;
}

memoized independent method indep_memo_0_t() throws {
    fired = true;
    throw;
}

memoized independent method indep_memo_0_nt() throws {
    fired = true;
}

memoized independent method indep_memo_1() -> (int) {
    fired = true;
    return 4;
}

memoized independent method indep_memo_2() -> (int, double) {
    fired = true;
    return (4, 7.2);
}

memoized independent method indep_memo_2_t() -> (int, double) throws {
    fired = true;
    throw;
}

memoized independent method indep_memo_2_nt() -> (int, double) throws {
    fired = true;
    return (4, 7.2);
}

template t {
    shared memoized method s_memo_0() {
        fired = true;
    }

    shared memoized method s_memo_0_t() throws {
        fired = true;
        throw;
    }

    shared memoized method s_memo_0_nt() throws {
        fired = true;
    }

    shared memoized method s_memo_1() -> (int) {
        fired = true;
        return 4;
    }

    shared memoized method s_memo_2() -> (int, double) {
        fired = true;
        return (4, 7.2);
    }

    shared memoized method s_memo_2_t() -> (int, double) throws {
        fired = true;
        throw;
    }

    shared memoized method s_memo_2_nt() -> (int, double) throws {
        fired = true;
        return (4, 7.2);
    }

    shared memoized independent method s_indep_memo_0() {
        fired = true;
    }

    shared memoized independent method s_indep_memo_0_t() throws {
        fired = true;
        throw;
    }

    shared memoized independent method s_indep_memo_0_nt() throws {
        fired = true;
    }

    shared memoized independent method s_indep_memo_1() -> (int) {
        fired = true;
        return 4;
    }

    shared memoized independent method s_indep_memo_2() -> (int, double) {
        fired = true;
        return (4, 7.2);
    }

    shared memoized independent method s_indep_memo_2_t() -> (int, double)
        throws {
        fired = true;
        throw;
    }

    shared memoized independent method s_indep_memo_2_nt() -> (int, double)
        throws {
        fired = true;
        return (4, 7.2);
    }
}

is t;

param zero_params       = [memo_0, indep_memo_0, s_memo_0, s_indep_memo_0];
param one_param         = [memo_1, indep_memo_1, s_memo_1, s_indep_memo_1];
param two_params        = [memo_2, indep_memo_2, s_memo_2, s_indep_memo_2];
param zero_params_t     = [memo_0_t, indep_memo_0_t, s_memo_0_t,
                           s_indep_memo_0_t];
param zero_params_nt    = [memo_0_nt, indep_memo_0_nt, s_memo_0_nt,
                           s_indep_memo_0_nt];
param two_params_t      = [memo_2_t, indep_memo_2_t, s_memo_2_t,
                           s_indep_memo_2_t];
param two_params_nt     = [memo_2_nt, indep_memo_2_nt, s_memo_2_nt,
                           s_indep_memo_2_nt];

method test() throws {
    local int i = 1;
    local double j = 1;

    #foreach m in (zero_params) {
        m();
        assert fired;
        fired = false;
        m();
        assert !fired;
    }

    #foreach m in (one_param) {
        i = m();
        assert fired && i == 4;
        fired = false;
        i = 1;
        i = memo_1();
        assert !fired && i == 4;
        i = 1;
    }

    #foreach m in (two_params) {
        (i, j) = m();
        assert fired && i == 4 && j == 7.2;
        i = j = 1;
        fired = false;
        (i, j) = m();
        assert !fired && i == 4 && j == 7.2;
        i = j = 1;
    }

    #foreach m in (zero_params_t) {
        try {
            m();
            assert false;
        } catch;
        assert fired;
        fired = false;
        try {
            m();
            assert false;
        } catch;
        assert !fired;
    }

    #foreach m in (zero_params_nt) {
        try {
            m();
        } catch {
            assert false;
        }
        assert fired;
        fired = false;
        try {
            m();
        } catch {
            assert false;
        }
        assert !fired;
    }

    #foreach m in (two_params_t) {
        try {
            (i, j) = m();
            assert false;
        } catch;
        assert fired && i == 1 && j == 1;
        fired = false;
        try {
            (i, j) = m();
            assert false;
        } catch;
        assert !fired && i == 1 && j == 1;
    }

    #foreach m in (two_params_nt) {
        try {
            (i, j) = m();
        } catch {
            assert false;
        }
        assert fired && i == 4 && j == 7.2;
        i = j = 1;
        fired = false;
        try {
            (i, j) = m();
        } catch {
            assert false;
        }
        assert !fired && i == 4 && j == 7.2;
        i = j = 1;
    }
}
