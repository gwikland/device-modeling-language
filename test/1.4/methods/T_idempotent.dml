/*
  Â© 2022 Intel Corporation
  SPDX-License-Identifier: MPL-2.0
*/
dml 1.4;
device test;
import "testing.dml";

header %{
    static bool fired = false;
%}
extern bool fired;

idempotent method idemp_0() {
    fired = true;
}

idempotent method idemp_0_t() throws {
    fired = true;
    throw;
}

idempotent method idemp_0_nt() throws {
    fired = true;
}

idempotent method idemp_1() -> (int) {
    fired = true;
    return 4;
}

idempotent method idemp_2() -> (int, double) {
    fired = true;
    return (4, 7.2);
}

idempotent method idemp_2_t() -> (int, double) throws {
    fired = true;
    throw;
}

idempotent method idemp_2_nt() -> (int, double) throws {
    fired = true;
    return (4, 7.2);
}

independent idempotent method indep_idemp_0() {
    fired = true;
}

independent idempotent method indep_idemp_0_t() throws {
    fired = true;
    throw;
}

independent idempotent method indep_idemp_0_nt() throws {
    fired = true;
}

independent idempotent method indep_idemp_1() -> (int) {
    fired = true;
    return 4;
}

independent idempotent method indep_idemp_2() -> (int, double) {
    fired = true;
    return (4, 7.2);
}

independent idempotent method indep_idemp_2_t() -> (int, double) throws {
    fired = true;
    throw;
}

independent idempotent method indep_idemp_2_nt() -> (int, double) throws {
    fired = true;
    return (4, 7.2);
}

template t {
    shared idempotent method s_idemp_0() {
        fired = true;
    }

    shared idempotent method s_idemp_0_t() throws {
        fired = true;
        throw;
    }

    shared idempotent method s_idemp_0_nt() throws {
        fired = true;
    }

    shared idempotent method s_idemp_1() -> (int) {
        fired = true;
        return 4;
    }

    shared idempotent method s_idemp_2() -> (int, double) {
        fired = true;
        return (4, 7.2);
    }

    shared idempotent method s_idemp_2_t() -> (int, double) throws {
        fired = true;
        throw;
    }

    shared idempotent method s_idemp_2_nt() -> (int, double) throws {
        fired = true;
        return (4, 7.2);
    }

    shared independent idempotent method s_indep_idemp_0() {
        fired = true;
    }

    shared independent idempotent method s_indep_idemp_0_t() throws {
        fired = true;
        throw;
    }

    shared independent idempotent method s_indep_idemp_0_nt() throws {
        fired = true;
    }

    shared independent idempotent method s_indep_idemp_1() -> (int) {
        fired = true;
        return 4;
    }

    shared independent idempotent method s_indep_idemp_2() -> (int, double) {
        fired = true;
        return (4, 7.2);
    }

    shared independent idempotent method s_indep_idemp_2_t() -> (int, double)
        throws {
        fired = true;
        throw;
    }

    shared independent idempotent method s_indep_idemp_2_nt() -> (int, double)
        throws {
        fired = true;
        return (4, 7.2);
    }
}

is t;

param zero_params       = [idemp_0, indep_idemp_0, s_idemp_0, s_indep_idemp_0];
param one_param         = [idemp_1, indep_idemp_1, s_idemp_1, s_indep_idemp_1];
param two_params        = [idemp_2, indep_idemp_2, s_idemp_2, s_indep_idemp_2];
param zero_params_t     = [idemp_0_t, indep_idemp_0_t, s_idemp_0_t,
                           s_indep_idemp_0_t];
param zero_params_nt    = [idemp_0_nt, indep_idemp_0_nt, s_idemp_0_nt,
                           s_indep_idemp_0_nt];
param two_params_t      = [idemp_2_t, indep_idemp_2_t, s_idemp_2_t,
                           s_indep_idemp_2_t];
param two_params_nt     = [idemp_2_nt, indep_idemp_2_nt, s_idemp_2_nt,
                           s_indep_idemp_2_nt];

method test() throws {
    local int i = 0;
    local double j = 0;

    #foreach m in (zero_params) {
        m();
        assert fired;
        fired = false;
        m();
        assert !fired;
    }

    #foreach m in (one_param) {
        i = m();
        assert fired && i == 4;
        fired = false;
        i = 0;
        i = idemp_1();
        assert !fired && i == 4;
        i = 0;
    }

    #foreach m in (two_params) {
        (i, j) = m();
        assert fired && i == 4 && j == 7.2;
        i = j = 0;
        fired = false;
        (i, j) = m();
        assert !fired && i == 4 && j == 7.2;
        i = j = 0;
    }

    #foreach m in (zero_params_t) {
        try {
            m();
            assert false;
        } catch;
        assert fired;
        fired = false;
        try {
            m();
            assert false;
        } catch;
        assert !fired;
    }

    #foreach m in (zero_params_nt) {
        try {
            m();
        } catch {
            assert false;
        }
        assert fired;
        fired = false;
        try {
            m();
        } catch {
            assert false;
        }
        assert !fired;
    }

    #foreach m in (two_params_t) {
        try {
            (i, j) = m();
            assert false;
        } catch;
        assert fired && i == 0 && j == 0;
        fired = false;
        try {
            (i, j) = m();
            assert false;
        } catch;
        assert !fired && i == 0 && j == 0;
    }

    #foreach m in (two_params_nt) {
        try {
            (i, j) = m();
        } catch {
            assert false;
        }
        assert fired && i == 4 && j == 7.2;
        i = j = 0;
        fired = false;
        try {
            (i, j) = m();
        } catch {
            assert false;
        }
        assert !fired && i == 4 && j == 7.2;
        i = j = 0;
    }
}
